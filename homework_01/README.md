Тази задача няма да е много практическа, защото в Python числата нямат максимална стриктна големина, а зависят от свободната памет. 
Все пак задачата ще ви даде възможност да се задълбочите в аритметучните операции.

Задачата цели да имплементира някаква форма на `Big integer`. Тоест число, което може теоретично да има безкрайно много цифри.

## Контрукция

Базовата дефиниция на класа `Bigint` може да изглежда така:

```python
class Bigint:
    def __init__(self):
        # self.sign = Знакът на числото
        # self.digits = [] Цифрите на числото 
        pass
```


Първото, което е важно да отбележа, е че имате сравнителна свобода във вътрешната имплементация на класа и на методите.
Полетата, които съм дал не са публични. Всички тестове ще сравняват един `Bigint` с друг `Bigint` или ще викат методи и ще проверяват резултата.
Все пак може да следвате полетата, които съм ви дал като насока.

Идеята на тези конкретни полета е да запазим всяка цифра като отделено число във лист и знака на числото като int, което е или -1 (за отрицателно число) или 1 (за положително). 
В нашата имплементация, нулата има знак 1, което улеснява някои неща.

В какъв ред са `digits`? Ваш избор. Не е нужно да мислите твърде много за `performance`, няма проблеми да викате `reverse()` на list-a, когато ви е нужно. 
Но направете ясен избор в какъв ред ги държите, за да получавате правилни резултати при аритметични операции.

Продължаваме с някои базови методи:

```python
class Bigint:
    def __init__(self):
        """
        Конструира нов Bigint със стойност "0" и положителен знак.
        Това може да означава празен вектор с цифри или масив с една цифра `0` -- ваш избор.
        """
        pass
        
    def is_positive(self):
        """
        Връща `True` ако числото е положително. Нулата не е положителна
        """
        pass
        
    def is_negative(self):
        """
        Връща `True` ако числото е отрицателно. Нулата не е отрицателна.
        """
        pass
```

Както бе споменато по-горе -- условие, което винаги трябва да е изпълнено е положителната нула и отрицателната нула да са равни.
Може да го имплементирате при конструиране, или може да или да се проверява експлицитно когато във вашата имплементация на `__eq__`.

(А можете ли просто да върнете `True` в собствена имплементация на Bigint, за да минават всички тестове? На теория да, на практика не, така че по-добре не пробвайте :))

Ще има нужда да конвертираме и `низове` до `bigint-ове`, така че нека имплементираме метода `from_string`, който е `@classmethod` 
(нещо, което все още не сме учили, но може да видите разяснение на това как да го използвате за нашите цели тук: https://stackoverflow.com/questions/5249813/create-python-objects-from-strings.
Може да намерите още информация за `@classmethod` тук: https://www.geeksforgeeks.org/classmethod-in-python/)

```python
class ParseError(Exception):
    """
    Throwed when the string used to parse a bigint from is invalid
    """


class Bigint:
    @classmethod
    def from_string(cls, s: str):
        """
        Очакваме низа да е във формат десетично цяло число с опционален знак, тоест всички тези
        неща би трябвало да върнат резултат с конструиран Bigint:
        
            Bigint.from_string("123") => положителен знак по подразбиране
            Bigint.from_string("+123")
            Bigint.from_string("-123")
            
        Това включва нулата, като имате предвид че, както казахме, +0 и -0 трябва да са
        еквивалентни.
        
        Ако подадения низ е празен, това връща същото като да сме подали "0". Ако подадения низ е
        само "+" или "-", ваше решение е дали да е нула или да е грешка, няма да се тества.
        
        Ако подадения низ започва с нули, това няма значение -- игнорират се. Тоест, конструиране с
        "00123" ще е същото като конструиране с "123".
        
        Ако сме подали низ, който включва каквито и да е други символи освен цифрите 0-9 (и
        опционален начален знак), очакваме да върнете `ParseError`.
        
        В Python можете да хвърлите грешка използвайки следната конструкция `raise ParseError("Съобщение за грешка")`
        """
        pass
```

## Сравнения

Трябва да може да сравняваме `Bigint-ове`. За целта ще имплементираме magic методите за сравнение.

```python
class Bigint:
    """
    Ако едното от числата е положително, а другото -- отрицателно, положителното е по-голямо.
    
    Ако едното от числата има по-голям брой цифри, то ще бъде по-голямото. (Стига да не са нули
    -- вероятно е добра идея да се погрижите да няма започващи нули при конструкция)
    
    Ако двете числа имат еднакъв брой цифри, лексикографско сравнение на числата ще ви даде
    правилен резултат -- от по-значимите цифри към по-малко значимите. Внимавайте в какъв ред
    си държите цифритe и дали не трябва да ги обърнете.
    
    Ако двете числа са отрицателни, сравнението по абсолютна стойност ще е обърнато (-1 е
    по-голямо от -2)
    """
    def __eq__(self):
        pass
    
    def __ne__(self):
        pass
        
    def __lt__(self):
        pass
        
    def __gt__(self):
        pass
        
    def __ge__(self):
        pass
    
    def __le__(self):
        pass
```

## Аритметични операции

Събирането и изваждането са единствените аритметични операции, които ще трябва да имплементираме

```python
class Bigint:
    def __add__(self, other):
    """
    За да съберете две числа, първия въпрос е: какви са им знаците?
    
    - Ако и двете са положителни, събираме ги цифра по цифра и слагаме на резултата положителен знак
    - Ако и двете са отрицателни, пак можем да ги съберем цифра по цифра и да сложим отрицателен знак на крайния резултат.
    - Ако имат различни знаци, намираме по-голямото *по абсолютна стойност*. Изваждаме цифрите
      на по-малкото от по-голямото. Знака на резултата е знака на по-голямото по абсолютна
      стойност. Ако са равни, резултата трябва да е нула (която винаги се очаква да е
      положителна).
      
    При събиране цифра по цифра, не забравяйте да пренасяте "едно наум" ако резултата е
    по-голям от десетична цифра. При различна дължина на списъците от цифри, можете да
    запълните с нули, да внимавате с индексите, или нещо по средата.
    
    Метода трябва да връща нов инстанция на класа Bigint
    """
        pass
    
    def __sub__(self, other):
    """
    Изваждането често се имплементира като събиране с отрицателен знак. Тоест, `A - B` е
    еквивалентно на `A + (-B)`. Можете да имплементирате изваждането като форма на събиране, и
    в него да пакетирате логиката. Или можете да проверите знаците и да разделите логиката по
    събиране и по изваждане между `add` и `sub`.
    
    При изваждане, също не забравяйте "едното наум", ако цифрата от която вадите е по-малката,
    което ще се преведе до едно "-1" на следващата цифра. Погрижете се винаги да вадите от
    по-голямото по абсолютна стойност число, и после сложете какъвто знак се налага.
    
    Метода трябва да връща нов инстанция на класа Bigint
    """
        pass
    
```

Внимавайте да не се оплетете в имплементацията на събиране и изваждане. Има доста дребни детайли и лесно можете да изпуснете някой, ако не карате стъпка по стъпка и ако се опитвате да имплементирате "оптимално" решение. Съветвам ви да си напишете няколко теста, да имплементирате работещо решение, и чак тогава да мислите дали можете да го промените както на вас ви харесва. Бързината на решението няма значение за задачата.

Бихте могли да си организирате логиката в отделни помощни функции, които са скрити за външния свят, примерно (не е задължително да подходите така):

```python
def add_digits(left: list, right: list) -> list:
    pass

def sub_digits(left: list, right: list) -> list:
    pass
```

Важно е да не забравяте, че това е `bigint`, целта му е да съхранява числа, които имат потенциално безкраен брой цифри. Ако по време на събиране или изваждане сумирате цифрите в нормално число то НЯМА ДА ПОЛУЧИТЕ ТОЧКИ ЗА РЕШЕНИЕТО СИ. 

## Съвети

- Не се фокусирайте върхи `performance`, освен ако не желаете да се пробвате.
- Пишете си тестове. Има `edge cases`, напишете си няколко извиквания, колкото да пробвате че сте нацелили логиката.
- Свободни сте да имплементирате и други magic методи, било то защото ви помагат (примерно може да ви е полезно да имплементирате str, за да си печатате числата в човешки вид) или просто защото искате да се пробвате, за да експериментирате с Python.

Примерно използване

```python
assert Bigint.from_string("10") + Bigint.from_string("10") == Bigint.from_string("20")
assert Bigint.from_string("10") < Bigint.from_string("20")
# Напишете и други такива ваши тестове
```
